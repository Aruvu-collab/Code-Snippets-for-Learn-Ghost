<script>
// Configuration
const GITHUB_RAW_URL = 'https://raw.githubusercontent.com/Aruvu-collab/Code-Snippets-for-Learn-Ghost/refs/heads/main/FAQ/faq.md';

// Markdown parser function
function parseMarkdownFAQ(markdown) {
  const lines = markdown.split('\n');
  const sections = [];
  let currentSection = null;
  let currentQuestion = null;
  let currentAnswerLines = [];

  lines.forEach(line => {
    if (line.startsWith('# ')) {
      // New section - save previous question if exists
      if (currentSection && currentQuestion) {
        currentSection.questions.push({
          question: currentQuestion,
          answer: processAnswerLines(currentAnswerLines)
        });
      }
      currentSection = {
        title: line.substring(2).trim(),
        questions: []
      };
      sections.push(currentSection);
      currentQuestion = null;
      currentAnswerLines = [];
    } else if (line.startsWith('## ')) {
      // New question - save previous question if exists
      if (currentQuestion && currentSection) {
        currentSection.questions.push({
          question: currentQuestion,
          answer: processAnswerLines(currentAnswerLines)
        });
      }
      currentQuestion = line.substring(3).trim();
      currentAnswerLines = [];
    } else if (currentQuestion !== null) {
      // Answer content (including empty lines for paragraphs)
      currentAnswerLines.push(line);
    }
  });

  // Add the last question
  if (currentSection && currentQuestion) {
    currentSection.questions.push({
      question: currentQuestion,
      answer: processAnswerLines(currentAnswerLines)
    });
  }

  return sections;
}

// Process answer lines to preserve formatting
function processAnswerLines(lines) {
  let html = '';
  let currentParagraph = '';
  let inList = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    if (line === '') {
      // Empty line - end current paragraph
      if (currentParagraph.trim()) {
        if (inList) {
          html += '</ul>';
          inList = false;
        }
        html += `<p>${currentParagraph.trim()}</p>`;
        currentParagraph = '';
      }
    } else if (line.startsWith('- ')) {
      // List item
      if (currentParagraph.trim()) {
        html += `<p>${currentParagraph.trim()}</p>`;
        currentParagraph = '';
      }
      if (!inList) {
        html += '<ul>';
        inList = true;
      }
      // Process markdown in list items (bold, italic, etc.)
      const listContent = processInlineMarkdown(line.substring(2).trim());
      html += `<li>${listContent}</li>`;
    } else {
      // Regular line - add to current paragraph
      if (inList) {
        html += '</ul>';
        inList = false;
      }
      currentParagraph += (currentParagraph ? ' ' : '') + line;
    }
  }
  
  // Handle remaining content
  if (inList) {
    html += '</ul>';
  }
  if (currentParagraph.trim()) {
    html += `<p>${currentParagraph.trim()}</p>`;
  }
  
  return html.trim();
}

// Process inline markdown (bold, italic, code)
function processInlineMarkdown(text) {
  return text
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // Bold
    .replace(/\*(.*?)\*/g, '<em>$1</em>')              // Italic
    .replace(/`(.*?)`/g, '<code>$1</code>');           // Code
}

// Generate HTML from parsed data
function generateFAQHTML(sections) {
  let html = '';
  
  sections.forEach(section => {
    html += `<div class="section-header">${section.title}</div>`;
    
    section.questions.forEach(qa => {
      html += `
        <div class="faq-item">
          <div class="faq-question">
            ${qa.question}
            <span class="arrow">â–¶</span>
          </div>
          <div class="faq-answer">
            ${qa.answer}
          </div>
        </div>
      `;
    });
  });
  
  return html;
}

// Add click handlers
function addFAQInteractivity() {
  const faqItems = document.querySelectorAll('.faq-item');

  faqItems.forEach(item => {
    const question = item.querySelector('.faq-question');
    const answer = item.querySelector('.faq-answer');
    const arrow = item.querySelector('.arrow');

    question.addEventListener('click', () => {
      const isOpen = answer.classList.contains('open');

      // Close all open answers
      document.querySelectorAll('.faq-answer').forEach(a => a.classList.remove('open'));
      document.querySelectorAll('.arrow').forEach(a => a.classList.remove('open'));

      // Toggle current item
      if (!isOpen) {
        answer.classList.add('open');
        arrow.classList.add('open');
      }
    });
  });
}

// Load and render FAQ
async function loadFAQ() {
  const faqContent = document.getElementById('faq-content');
  const faqLoading = document.getElementById('faq-loading');

  try {
    const response = await fetch(GITHUB_RAW_URL);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const markdown = await response.text();
    const sections = parseMarkdownFAQ(markdown);
    const html = generateFAQHTML(sections);
    
    faqContent.innerHTML = html;
    faqLoading.style.display = 'none';
    faqContent.style.display = 'block';
    
    // Add interactivity
    addFAQInteractivity();
    
  } catch (error) {
    console.error('Error loading FAQ:', error);
    faqLoading.innerHTML = 'Error loading FAQ. Please try again later.';
  }
}

// Initialize when DOM is loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', loadFAQ);
} else {
  loadFAQ();
}
</script>